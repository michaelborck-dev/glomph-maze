# This file was generated automatically using `configure'.
# Do not edit this file by hand.

# Date: Wed Oct  1 21:58:04 AWST 2025

${START_STRING_QUOTING_LIBRARY}


## supported characters (tab + newline + printable ASCII)

# these constant strings are used during string escaping; the
# quotation mark, apostrophe and grave accent are each repeated twice
# to fool broken syntax-highlighting editors (emacs makefile-mode in
# particular)

# NOTE: char_tab and char_newline are special -- to overcome
# shortcomings in Makefile syntax, they must be exported through the
# environment to sub-processes, and their values must be set in all
# generated shell scripts

define char_tab
	:
endef
define char_newline
	:
	:
endef
char_newline := $(subst ${char_tab},,${char_newline})
char_tab := $(subst :,,${char_tab})
export char_tab
export char_newline
nil :=
char_space := ${nil} ${nil}
char_dollar_sign := $$
char_reverse_solidus := \${nil}
define char_number_sign
#
endef
char_quotation_mark := "
char_quotation_mark := "
char_apostrophe := '
char_apostrophe := '
char_grave_accent := `
char_grave_accent := `
char_exclamation_mark := !
char_percent_sign := %
char_ampersand := &
char_left_parenthesis := (
char_right_parenthesis := )
char_asterisk := *
char_plus_sign := +
char_comma := ,
char_hyphen_minus := -
char_full_stop := .
char_solidus := /
char_digit_zero := 0
char_digit_one := 1
char_digit_two := 2
char_digit_three := 3
char_digit_four := 4
char_digit_five := 5
char_digit_six := 6
char_digit_seven := 7
char_digit_eight := 8
char_digit_nine := 9
char_colon := :
char_semicolon := ;
char_less_than_sign := <
char_equals_sign := =
char_greater_than_sign := >
char_question_mark := ?
char_commercial_at := @
char_latin_capital_letter_a := A
char_latin_capital_letter_b := B
char_latin_capital_letter_c := C
char_latin_capital_letter_d := D
char_latin_capital_letter_e := E
char_latin_capital_letter_f := F
char_latin_capital_letter_g := G
char_latin_capital_letter_h := H
char_latin_capital_letter_i := I
char_latin_capital_letter_j := J
char_latin_capital_letter_k := K
char_latin_capital_letter_l := L
char_latin_capital_letter_m := M
char_latin_capital_letter_n := N
char_latin_capital_letter_o := O
char_latin_capital_letter_p := P
char_latin_capital_letter_q := Q
char_latin_capital_letter_r := R
char_latin_capital_letter_s := S
char_latin_capital_letter_t := T
char_latin_capital_letter_u := U
char_latin_capital_letter_v := V
char_latin_capital_letter_w := W
char_latin_capital_letter_x := X
char_latin_capital_letter_y := Y
char_latin_capital_letter_z := Z
char_left_square_bracket := [
char_right_square_bracket := ]
char_circumflex_accent := ^
char_low_line := _
char_latin_small_letter_a := a
char_latin_small_letter_b := b
char_latin_small_letter_c := c
char_latin_small_letter_d := d
char_latin_small_letter_e := e
char_latin_small_letter_f := f
char_latin_small_letter_g := g
char_latin_small_letter_h := h
char_latin_small_letter_i := i
char_latin_small_letter_j := j
char_latin_small_letter_k := k
char_latin_small_letter_l := l
char_latin_small_letter_m := m
char_latin_small_letter_n := n
char_latin_small_letter_o := o
char_latin_small_letter_p := p
char_latin_small_letter_q := q
char_latin_small_letter_r := r
char_latin_small_letter_s := s
char_latin_small_letter_t := t
char_latin_small_letter_u := u
char_latin_small_letter_v := v
char_latin_small_letter_w := w
char_latin_small_letter_x := x
char_latin_small_letter_y := y
char_latin_small_letter_z := z
char_left_curly_bracket := {
char_vertical_line := |
char_right_curly_bracket := }
char_tilde := ~


## character classes

charclass_ascii_space := \
char_tab \
char_newline \
char_space

charclass_ascii_punct := \
char_exclamation_mark \
char_quotation_mark \
char_number_sign \
char_dollar_sign \
char_percent_sign \
char_ampersand \
char_apostrophe \
char_left_parenthesis \
char_right_parenthesis \
char_asterisk \
char_plus_sign \
char_comma \
char_hyphen_minus \
char_full_stop \
char_solidus \
char_colon \
char_semicolon \
char_less_than_sign \
char_equals_sign \
char_greater_than_sign \
char_question_mark \
char_commercial_at \
char_left_square_bracket \
char_reverse_solidus \
char_right_square_bracket \
char_circumflex_accent \
char_low_line \
char_grave_accent \
char_left_curly_bracket \
char_vertical_line \
char_right_curly_bracket \
char_tilde

charclass_ascii_digit := \
char_digit_zero \
char_digit_one \
char_digit_two \
char_digit_three \
char_digit_four \
char_digit_five \
char_digit_six \
char_digit_seven \
char_digit_eight \
char_digit_nine

charclass_ascii_upper := \
char_latin_capital_letter_a \
char_latin_capital_letter_b \
char_latin_capital_letter_c \
char_latin_capital_letter_d \
char_latin_capital_letter_e \
char_latin_capital_letter_f \
char_latin_capital_letter_g \
char_latin_capital_letter_h \
char_latin_capital_letter_i \
char_latin_capital_letter_j \
char_latin_capital_letter_k \
char_latin_capital_letter_l \
char_latin_capital_letter_m \
char_latin_capital_letter_n \
char_latin_capital_letter_o \
char_latin_capital_letter_p \
char_latin_capital_letter_q \
char_latin_capital_letter_r \
char_latin_capital_letter_s \
char_latin_capital_letter_t \
char_latin_capital_letter_u \
char_latin_capital_letter_v \
char_latin_capital_letter_w \
char_latin_capital_letter_x \
char_latin_capital_letter_y \
char_latin_capital_letter_z

charclass_ascii_lower := \
char_latin_small_letter_a \
char_latin_small_letter_b \
char_latin_small_letter_c \
char_latin_small_letter_d \
char_latin_small_letter_e \
char_latin_small_letter_f \
char_latin_small_letter_g \
char_latin_small_letter_h \
char_latin_small_letter_i \
char_latin_small_letter_j \
char_latin_small_letter_k \
char_latin_small_letter_l \
char_latin_small_letter_m \
char_latin_small_letter_n \
char_latin_small_letter_o \
char_latin_small_letter_p \
char_latin_small_letter_q \
char_latin_small_letter_r \
char_latin_small_letter_s \
char_latin_small_letter_t \
char_latin_small_letter_u \
char_latin_small_letter_v \
char_latin_small_letter_w \
char_latin_small_letter_x \
char_latin_small_letter_y \
char_latin_small_letter_z

charclass_all := \
${charclass_ascii_space} \
${charclass_ascii_punct} \
${charclass_ascii_digit} \
${charclass_ascii_upper} \
${charclass_ascii_lower}

charclass_ascii_id := \
${charclass_ascii_lower} \
${charclass_ascii_upper} \
${charclass_ascii_digit} \
char_low_line


## case-folding functions

# ucase: convert lower case -> upper case
$(eval \
ucase ${char_equals_sign} $(subst ${char_comma}${char_space},${char_comma},$(foreach charname,$(strip ${charclass_ascii_lower}),$$${char_left_parenthesis}subst $$(value ${charname})${char_comma}$$(value $(subst char_latin_small_letter_,char_latin_capital_letter_,${charname}))${char_comma}))${char_dollar_sign}1$(subst ${char_space},,$(patsubst %,${char_right_parenthesis},$(strip ${charclass_ascii_lower}))))


## string quoting functions

charclass_q_safe := \
char_newline \
char_hyphen_minus \
char_equals_sign \
char_plus_sign \
char_full_stop \
char_comma \
char_colon \
char_solidus \
${charclass_ascii_id}

# characters that need simple backslashing for the shell
charclass_q_unsafe := \
$(filter-out char_reverse_solidus ${charclass_q_safe},${charclass_all}) \
char_reverse_solidus

# q: re-quote $1 for interpretation as a shell word
$(eval \
q ${char_equals_sign} ${char_dollar_sign}${char_left_parenthesis}subst ${char_dollar_sign}{char_newline},"${char_dollar_sign}${char_dollar_sign}{char_newline}",$(subst ${char_comma}${char_space},${char_comma},$(foreach charname,$(strip ${charclass_q_unsafe}),$$${char_left_parenthesis}subst $$(value ${charname})${char_comma}$${char_reverse_solidus}$$(value ${charname})${char_comma}))${char_dollar_sign}1$(subst ${char_space},,$(patsubst %,${char_right_parenthesis},$(strip ${charclass_q_unsafe})))${char_right_parenthesis})

# characters that need simple backslashing for the C compiler (we pass
# apostrophe unmodified at the moment; this works fine for
# double-quoted string initializers)
charclass_cq_unsafe := \
char_question_mark \
char_quotation_mark \
char_reverse_solidus

# other C quoting we handle:
#     <TAB> -> \t
#     <NEWLINE> -> \n

# cq: re-quote $1 for inclusion in a literal C string
$(eval \
cq ${char_equals_sign} ${char_dollar_sign}${char_left_parenthesis}subst ${char_dollar_sign}{char_tab}${char_comma}${char_reverse_solidus}t${char_comma}${char_dollar_sign}${char_left_parenthesis}subst ${char_dollar_sign}{char_newline}${char_comma}${char_reverse_solidus}n${char_comma}$(subst ${char_comma}${char_space},${char_comma},$(foreach charname,$(strip ${charclass_cq_unsafe}),$$${char_left_parenthesis}subst $$(value ${charname})${char_comma}$${char_reverse_solidus}$$(value ${charname})${char_comma}))${char_dollar_sign}1$(subst ${char_space},,$(patsubst %,${char_right_parenthesis},$(strip ${charclass_cq_unsafe})))${char_right_parenthesis}${char_right_parenthesis})

# ccq: re-quote $1 for inclusion in a C or C++ comment (the /* ... */ syntax or the // ... syntax )

# comment delimiters
#     */ -> *//*
#     <NEWLINE> -> <NEWLINE>//*/<SPACE>/*
ccq = $(subst ${char_newline},${char_newline}${char_solidus}${char_solidus}${char_asterisk}${char_solidus}${char_space}${char_solidus}${char_asterisk},$(subst ${char_asterisk}${char_solidus},${char_asterisk}${char_solidus}${char_solidus}${char_asterisk},$1))

# mw: quoting for treatment as a make target or dependency

# very bizarre backslashing rules
#     \\<SPACE> -> error
#     \\<TAB> -> error
#     \\| -> error
#     <SPACE> -> \<SPACE>
#     <TAB> -> \<TAB>
#     | -> \|
#     : -> error

# NOTE: the actual handling of reverse solidus (\) and colon (:) is
# too complicated and silly to go into; basically i regard the GNU
# Make handling of these characters to be a bug

# FIXME: once the GNU Make developers decide on a reasonable solution
# to this problem, mw will need to be rewritten

mw = $(if $(findstring ${char_reverse_solidus}${char_reverse_solidus}${char_space},$(subst ${char_tab},${char_space},$(subst ${char_vertical_line},${char_space},$1))),$(error two reverse solidus characters (${char_reverse_solidus}${char_reverse_solidus}) followed by a space character (${char_space})${char_comma} a tab character (${char_tab})${char_comma} or a vertical line character (${char_vertical_line}) are not yet supported in GNU make targets or dependencies; such a pattern occurs at least once in the string ${char_grave_accent}$1${char_apostrophe}),$(if $(findstring ${char_colon},$1)$(findstring ${char_semicolon},$1)$(findstring ${char_dollar_sign}${char_commercial_at},$1),$(error the colon character (${char_colon}), semicolon character (${char_semicolon}) and dollar sign-commercial at character sequence (${char_dollar_sign}${char_commercial_at}) are not yet supported in GNU Make targets or dependencies; such a character or sequence occurs at least once in the string ${char_grave_accent}$1${char_apostrophe}),$(subst ${char_reverse_solidus}_open_reverse_solidus,${char_reverse_solidus},$(subst ${char_reverse_solidus}_close_reverse_solidus,,$(subst ${char_reverse_solidus}_close_reverse_solidus${char_reverse_solidus},${char_reverse_solidus}${char_reverse_solidus},$(subst ${char_reverse_solidus}_close_reverse_solidus${char_reverse_solidus}_open_reverse_solidus,${char_reverse_solidus}_open_reverse_solidus,$(subst ${char_vertical_line},${char_reverse_solidus}${char_vertical_line},$(subst ${char_colon},${char_reverse_solidus}${char_colon},$(subst ${char_tab},${char_reverse_solidus}${char_tab},$(subst ${char_space},${char_reverse_solidus}${char_space},$(subst ${char_reverse_solidus},${char_reverse_solidus}_open_reverse_solidus${char_reverse_solidus}_close_reverse_solidus,$1)))))))))))

# mq: quote dollar signs (useful when passing make variable
# settings through the command-line to a recursive invocation of make)
mq = $(subst ${char_dollar_sign},${char_dollar_sign}${char_dollar_sign},$1)

# shell: run shell commands with arguments possibly containing
# strings quoted by $(call q,...)
shell = $(shell char_newline=`echo ;echo :`; char_newline="$${char_newline%:}"; export char_newline; ${SHELL} -c $(call q,$1))

# xq(xu): primitive (un-)quoting for s; this
# allows us to use built-in functions expecting space-separated lists
# when we have single-item lists possibly containing embedded spaces,
# and allows us to treat solidus (/) as a normal word character in
# s patterns and inputs.

#     _ <-> __
#     / <-> _|
#     <SPACE> <-> _-
#     <TAB> <-> _=
#     % <-> _@

xq = $(subst %,_@,$(subst ${char_tab},_=,$(subst ${char_space},_-,$(subst ${char_solidus},_|,$(subst _,__,$1)))))
xu = $(subst __.,_,$(subst _|,${char_solidus},$(subst _-,${char_space},$(subst _=,${char_tab},$(subst _@,%,$(subst __,__.,$1))))))

# s: like patsubst, but makes only a single replacement; $1 is source
# pattern (treated as a single word,) $2 is replacement pattern
# (treated as a single word,) and $3 is the string to act upon (also
# treated as a single word); note that you need to quote the non-%
# parts of $1 and $2 using $(call xq,...)
s = $(call xu,$(patsubst $1,$2,$(call xq,$3)))

# qq: composition of q and q
qq = $(call q,$(call q,$1))

# qs: composition of q and s
qs = $(call q,$(call s,$1,$2,$3))

# qcq: composition of q and cq
qcq = $(call q,$(call cq,$1))

# qmq: composition of q and mq
qmq = $(call q,$(call mq,$1))

# qmqs: composition of qmq and s
qmqs = $(call qmq,$(call s,$1,$2,$3))

# qxq: composition of q and xq
qxq = $(call q,$(call xq,$1))

# qxqs: composition of qxq and s
qxqs = $(call qxq,$(call s,$1,$2,$3))

# qsxu: qs with $(call xu,$3) for $3
qsxu = $(call qs,$1,$2,$(call xu,$3))

# mwxq: composition of mw and xq
mwxq = $(call mw,$(call xq,$1))

# idx: index of $1 in $2
lastword = $(word $(words $1),$1)
idx = $(if $1,$(strip $(if $2,$(call idx,$1,$(filter-out $(call lastword,$2),$2)) $(if $(subst $(call lastword,$2),,$1),,$(words $2)))))

${END_STRING_QUOTING_LIBRARY}

MAKEFILE = GNUmakefile
_SHELL := /bin/sh
ifeq ($(subst default,undefined,$(origin date)),undefined)
date := Wed Oct${char_space}${char_space}1 21:58:04 AWST 2025
endif
ifeq ($(subst default,undefined,$(origin isodate)),undefined)
isodate := 2025-10-01
endif
ifeq ($(subst default,undefined,$(origin build)),undefined)
build := arm64-apple-darwin25
endif
ifeq ($(subst default,undefined,$(origin srcdir)),undefined)
srcdir := .
endif
ifeq ($(subst default,undefined,$(origin host)),undefined)
host := arm64-apple-darwin25
endif


## copy of main Makefile

include makefile.cp

## additional rules

GNUmakefile makefile.cp:: $(call mw,$(srcdir))/configure $(call mw,$(srcdir))/Makefile config.status ; $(SHELL) config.status && test -f $(call q,$@) && touch $(call q,$@)

distclean:: ; $(REMOVE) GNUmakefile config.status makefile.cp

clean:: ; $(REMOVE) _conftmp.*
